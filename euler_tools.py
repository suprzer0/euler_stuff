""" 
Various stuff I've written to help w/ solving project euler problems

python 2.6+
"""

from functools import reduce
from itertools import islice, count, cycle, compress, chain, combinations
import math
import operator

# ======= Calculations =======

def mul(iterable):
    """
    Multiplies all of the values from an iterable.
    Similar to how sum() adds all of the values from an iterable.

    >>> mul([2,3])
    6
    >>> mul(xrange(1,6)) == math.factorial(5)
    True
    """

    return reduce(operator.mul, iterable, 1)

def comb(n, r):
    """
    Finds the number of combinations for n items taken r at a time.

    >>> comb(6, 6)
    1
    >>> comb(6, 1)
    6
    """
    return math.factorial(n) / (math.factorial(r)*(math.factorial(n-r)))

# ======= Iterators =======

class CachedIter(object):
    """ 
    Stores the output from an iterator so previously generated values can be accessed again.
    Useful for infinite series.
    
    >>> l = CachedIter(xrange(1,5))
    >>> l[2]
    3
    >>> l[:2]
    [1, 2]

    
    """

    def __init__(self, iterator):
        self._iter = iter(iterator)
        self.cache = []

    def __iter__(self):
        for iter_index in count(0):
            try:
                item = self.cache[iter_index]
            except IndexError:
                item = self.next()

            yield item

    def __getitem__(self, index):
        if isinstance(index, slice):
            return list(islice(iter(self), index.start, index.stop, index.step))
        else:
            return islice(iter(self), index, index+1).next()

    def next(self):
        n = self._iter.next()
        self.cache.append(n)
        return n

class AscendingCachedIter(CachedIter):
    """
    A CachedIter where the sequence generated by the iterator is ascending.
    This allows for checking if an infinite sequence contains a value w/o running into an infinite loop
    for values not in the sequence. This only holds true for values inside the range of the iterator.

    >>> evens = AscendingCachedIter(count(2, 2))
    >>> 2 in evens
    True
    >>> 3 in evens
    False

    """

    def __contains__(self, item):
        if not isinstance(item, (int, long)):
            return False

        if self.cache:
            if item in self.cache:
                return True

            next_val = self.cache[-1]
        else:
            next_val = None

        while item > next_val:
            next_val = self.next()

            if item == next_val:
                return True

        return False


def fib():
    """ Simple generator for the fibonacci sequence """

    a, b = 1, 1
    for dummy in count():
        yield a
        a, b = b, a+b

def find_primes():
    """ Very naive generator for finding primes. """
    found_primes = []

    yield 2
    for v in count(3, 2):
        for p in found_primes:
            if v % p == 0:
                break
        else:
            found_primes.append(v)
            yield v


def eratos():
    D = {9:3, 25:5}
    yield 2
    yield 3
    yield 5
    MASK = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,)
    MODULOS = frozenset((1, 7, 11, 13, 17, 19, 23, 29))

    for q in compress(
            count(7, 2),
            cycle(MASK)):
        p = D.pop(q, None)
        if p is None:
            D[q*q] = q
            yield q
        else:
            x = q + 2*p
            while x in D or (x%30) not in MODULOS:
                x += 2*p
            D[x] = p

# Some CachedIterators. Use these rather then the generator directly.
primes = AscendingCachedIter(find_primes())
e_primes = AscendingCachedIter(eratos())
fib_numbers = AscendingCachedIter(fib())

def find_triangle_numbers(start=0):
    """ Generates triangle numbers """
    val = sum(range(1,start))

    for i in count(start+1):
        yield val
        val += i

def find_prime_factors(n):
    """ Finds the prime factors of a positive integer n """
    
    while n > 1:
        for p in e_primes:
            if n % p == 0:
                yield p
                n /= p
                break

def find_divisors_from_primes(prime_factors):
    """ 
    Generates a set of divisors from a list of prime factors 
    
    >>> find_divisors_from_primes([2,2,3])
    set([1, 2, 3, 4, 6, 12])
    
    """

    divisors = set([1, mul(prime_factors)])

    return divisors.union(mul(vals) for vals in chain.from_iterable(combinations(prime_factors, r) for r in range(1, len(prime_factors))))

def find_divisors(n):
    """
    Generates a set of divisors from the number n 

    >>> find_divisors(12)
    set([1, 2, 3, 4, 6, 12])
    """
    return find_divisors_from_primes(list(find_prime_factors(n)))

if __name__ == '__main__':
    import doctest
    doctest.testmod()
