""" 
Various stuff I've written to help w/ solving project euler problems

python 2.6+, 3.3+
"""

from functools import reduce
from itertools import islice, count, cycle, compress, chain, combinations
import math
import numbers
import operator

# ======= Calculations =======

def mul(iterable):
    """
    Multiplies all of the values from an iterable.
    Similar to how sum() adds all of the values from an iterable.

    >>> mul([2,3])
    6
    >>> mul(range(1,6)) == math.factorial(5)
    True
    """

    return reduce(operator.mul, iterable, 1)

def comb(n, r):
    """
    Finds the number of combinations for n items taken r at a time.

    >>> comb(6, 6)
    1
    >>> comb(6, 1)
    6
    """
    return math.factorial(n) // (math.factorial(r)*(math.factorial(n-r)))

def all_combos(s):
    """ 
        Generates tuples of all possible combinations of the items in s.

        >>> combos = list(all_combos([2,2,3]))
        >>> (2, 2) in combos
        True
        >>> (2,) in combos
        True
    """

    return chain.from_iterable((tuple(c) for c in combinations(s, r)) for r in range(1, len(s)+1))


def powerset(s):
    """
        Creates a set of all possible subsets of s except for the empty set.
        >>> p_set = powerset([1,2,3])
        >>> {1,2,3} in p_set
        True
        >>> {1,3} in p_set
        True
        >>> {2,} in p_set
        True
    """

    return frozenset(frozenset(c) for c in all_combos(s))

# ======= Iterators =======

class CachedIter(object):
    """ 
    Stores the output from an iterator so previously generated values can be accessed again.
    Useful for infinite series.
    
    >>> l = CachedIter(iter(range(1,5)))
    >>> l[2]
    3
    >>> l[2]
    3
    >>> l[:2]
    [1, 2]

    
    """

    def __init__(self, iterator):
        self._iter = iter(iterator)
        self.cache = []

    def __iter__(self):
        for iter_index in count(0):
            try:
                item = self.cache[iter_index]
            except IndexError:
                item = next(self)

            yield item

    def __getitem__(self, index):
        if isinstance(index, slice):
            s = islice(iter(self), index.start, index.stop, index.step)
            if index.stop:
                return list(s)
            else:
                return self.__class__(s)
        else:
            return next(islice(iter(self), index, index+1))

    def next(self):
        n = next(self._iter)
        self.cache.append(n)
        return n

    __next__ = next

class AscendingCachedIter(CachedIter):
    """
    A CachedIter where the sequence generated by the iterator is ascending.
    This allows for checking if an infinite sequence contains a value w/o running into an infinite loop
    for values not in the sequence. This only holds true for values inside the range of the iterator.

    >>> evens = AscendingCachedIter(count(2, 2))
    >>> 2 in evens
    True
    >>> 3 in evens
    False

    """

    def __contains__(self, item):
        if not isinstance(item, numbers.Number):
            return False

        if self.cache:
            if item in self.cache:
                return True

            next_val = self.cache[-1]
        else:
            next_val = None

        while next_val is None or item > next_val:
            next_val = next(self)

            if item == next_val:
                return True

        return False


def fib():
    """ Simple generator for the fibonacci sequence """

    a, b = 1, 1
    for dummy in count():
        yield a
        a, b = b, a+b

def eratos():
    D = {9:3, 25:5}
    yield 2
    yield 3
    yield 5
    MASK = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,)
    MODULOS = frozenset((1, 7, 11, 13, 17, 19, 23, 29))

    for q in compress(
            count(7, 2),
            cycle(MASK)):
        p = D.pop(q, None)
        if p is None:
            D[q*q] = q
            yield q
        else:
            x = q + 2*p
            while x in D or (x%30) not in MODULOS:
                x += 2*p
            D[x] = p

# Some CachedIterators. Use these rather then the generator directly.
primes = AscendingCachedIter(eratos())
fib_numbers = AscendingCachedIter(fib())

def fib_num(idx):
  gold_ratio = (1+math.sqrt(5))/2
  return int((gold_ratio**idx - (1 - gold_ratio)**idx)/math.sqrt(5))

def find_triangle_numbers(start=0):
    """ Generates triangle numbers """
    val = sum(range(1,start))

    for i in count(start+1):
        yield val
        val += i

def find_prime_factors(n):
    """ Finds the prime factors of a positive integer n """
    
    while n > 1:
        for p in primes:
            if n % p == 0:
                yield p
                n /= p
                break

def find_divisors_from_primes(prime_factors):
    """ 
    Generates a set of divisors from a list of prime factors 
    
    >>> divisors = find_divisors_from_primes([2,2,3])
    >>> sorted(divisors)
    [1, 2, 3, 4, 6, 12]
    
    """

    return {1} | set(mul(vals) for vals in all_combos(prime_factors))

def find_divisors(n):
    """
    Generates a set of divisors from the number n 

    >>> divisors = find_divisors(12)
    >>> sorted(divisors)
    [1, 2, 3, 4, 6, 12]
    """
    return find_divisors_from_primes(list(find_prime_factors(n)))

if __name__ == '__main__':
    import doctest
    doctest.testmod()
